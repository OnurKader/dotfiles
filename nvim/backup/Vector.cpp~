/* g++ -c main.cpp */
/* g++ main.o -o SFML_RUN -lsfml-graphics -lsfml-window -lsfml-system */
/* ./SFML_RUN */

#include <iostream>
#include <cmath>
#include <random>
#include <chrono>
#include "Vector.h"

template <typename T>
Vector<T>::Vector()
{
	//	╭───╮
	//	│ 0 │
	//	│ 0 │
	//	╰───╯

	x = 0;
	y = 0;
	c_angle = 0.0;
	p_angle = 0.0;
}

template <typename T>
Vector<T>::Vector(T a, T b)
{
	//	╭───╮
	//	│ 0 │
	//	│ 0 │
	//	╰───╯

	this->x = a;
	this->y = b;
	this->c_angle = 0.0;
	this->p_angle = 0.0;
}

template <typename T>
Vector<T>::Vector(const Vector<T> &other)
{
	this->x = other.x;
	this->y = other.y;
	p_angle = 0.0;
	c_angle = 0.0;
}

template <typename T>
Vector<T> *Vector<T>::add(Vector<T> &other)
{
	this->x += other.x;
	this->y += other.y;
	return this;
}

template <typename T>
Vector<T> *Vector<T>::add(T val)
{
	this->x += val;
	this->y += val;
	return this;
}

template <typename T>
Vector<T> *Vector<T>::add(Vector<T> &a, Vector<T> &b)
{
	return a.add(b);
}

template <typename T>
Vector<T> *Vector<T>::sub(Vector<T> &other)
{
	this->x -= other->x;
	this->y -= other->y;
	return this;
}

template <typename T>
Vector<T> *Vector<T>::sub(T val)
{
	this->x -= val;
	this->y -= val;
	return this;
}

template <typename T>
Vector<T> *Vector<T>::sub(Vector<T> &a, Vector<T> &b)
{
	return a.sub(b);
}

template <typename T>
Vector<T> *Vector<T>::mult(Vector<T> &other)
{
	this->x *= other->x;
	this->y *= other->y;
	return this;
}

template <typename T>
Vector<T> *Vector<T>::mult(T val)
{
	this->x *= val;
	this->y *= val;
	return this;
}

template <typename T>
Vector<T> *Vector<T>::div(T val)
{
	this->x /= val;
	this->y /= val;
	return this;
}

template <typename T>
void Vector<T>::set(T a, T b)
{
	x = a;
	y = b;
}

template <typename T>
void Vector<T>::set(Vector<T> &other)
{
	this->x = other.x;
	this->y = other.y;
}

template <typename T>
void Vector<T>::print()
{
	std::cout << "[ " << x << ", " << y << " ]" << std::endl;
}

template <typename T>
Vector<T> *Vector<T>::copy()
{
	return (new Vector<T>(this->x, this->y));
}

template <typename T>
Vector<T> *Vector<T>::rotate(double angle)
{
	c_angle = -angle;
	double r_angle = c_angle - p_angle;
	this->x = this->x * cos(r_angle) - this->x * sin(r_angle);
	this->y = this->y * sin(r_angle) + this->y * cos(r_angle);
	p_angle = c_angle;
	return this;
}

template <typename T>
double Vector<T>::Random()
{
	std::mt19937_64 rng;
	uint64_t timeSeed = std::chrono::high_resolution_clock::now().time_since_epoch().count();
	std::seed_seq ss{uint32_t(timeSeed & 0xFFFFFFFF), uint32_t(timeSeed >> 32)};
	rng.seed(ss);
	std::uniform_real_distribution<double> Random(0, 1);
	return Random(rng);
}

template <typename T>
Vector<T> *Vector<T>::random()
{
	return new Vector<T>(Random(), Random());
}

template <typename T>
Vector<T> *Vector<T>::random(T end)
{
	return new Vector<T>((T)(Random() * end), (T)(Random() * end));
}

template <typename T>
Vector<T> *Vector<T>::random(T begin, T end)
{
	return new Vector<T>((T)(begin + Random() * (end - begin)), (T)(begin + Random() * (end - begin)));
}

template <typename T>
double Vector<T>::heading()
{
	return atan2(y, x);
}

template <typename T>
T Vector<T>::mag()
{
	return (T)sqrt(x * x + y * y);
}

template <typename T>
T Vector<T>::magSq()
{
	return (T)(x * x + y * y);
}

template <typename T>
Vector<T> *Vector<T>::normalize()
{
	T m = this->mag();
	if (m != 0 && m != 1)
		this->div(m);
	return this;
}

template <typename T>
Vector<T> *Vector<T>::normalise() { return this->normalize(); }

template <typename T>
double Vector<T>::angleBetween(Vector<T> &a, Vector<T> &b)
{
	if ((a.x == 0.0 && a.y == 0.0) || (b.x == 0.0 && b.y == 0.0))
		return 0.0;
	T dot = a.x * b.x + a.y * b.y;
	T amt = dot / (a.mag() * b.mag());
	if (amt <= -1.0)
		return M_PI;
	else if (amt >= 1.0)
		return 0.0;
	return acos(amt);
}

template <typename T>
Vector<T> *Vector<T>::setMag(T val)
{
	this->normalize();
	this->mult(val);
	return this;
}

template <typename T>
Vector<T> *Vector<T>::limit(T max)
{
	if (this->magSq() > max * max)
	{
		this->normalize();
		this->mult(max);
	}
	return this;
}

template <typename T>
double Vector<T>::dist(Vector<T> &other)
{
	T dx = this->x - other.x;
	T dy = this->y - other.y;
	return sqrt(dx * dx + dy * dy);
}

template <typename T>
double Vector<T>::dist(Vector<T> &a, Vector<T> &b)
{
	T dx = a.x - b.x;
	T dy = a.y - b.y;
	return sqrt(dx * dx + dy * dy);
}

template <typename T>
Vector<T> *Vector<T>::fromAngle(double angle)
{
	return new Vector<T>(cos(angle), sin(angle));
}

template <typename T>
Vector<T>* Vector<T>::operator+(Vector<T>& other)
{
	return new Vector<T>(this->x + other.x, this->y + other.y);
}

template <typename T>
Vector<T>* Vector<T>::operator-(Vector<T>& other)
{
	return new Vector<T>(this->x - other.x, this->y - other.y);
}

template <typename T>
Vector<T>* Vector<T>::operator*(Vector<T>& other)
{
	return new Vector<T>(this->x * other.x, this->y * other.y);
}

template <typename T>
Vector<T>* Vector<T>::operator*(double val){
	return new Vector<T>(this->x * val, this->y * val);
}

template <typename T>
Vector<T>* Vector<T>::operator/(double val){
	return new Vector<T>(this->x / val, this->y / val);
}

template <typename T>
void Vector<T>::operator=(Vector<T>& other){
	this->set(other);
}

class VectorD : public Vector<double>
{
	using Vector<double>::Vector;
};

class VectorF : public Vector<float>
{
	using Vector<float>::Vector;
};

class VectorI : public Vector<int>
{
	using Vector<int>::Vector;
};

