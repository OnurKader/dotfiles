#include <iostream>
#define OLC_PGE_APPLICATION
#include "olcPixelGameEngine.h"

template <typename Type>
void swap(Type &a, Type &b)
{
    Type temp = b;
    b = a;
    a = temp;
}

class Polygon : public olc::PixelGameEngine
{
  public:
    Polygon()
    {
        sAppName = "Collision!";
    }

    struct vec2d
    {
        float x, y;
    };

    struct polygon
    {
        std::vector<vec2d> p;
        vec2d pos;
        float angle;
        std::vector<vec2d> o;
        bool overlap = false;
    };

    std::vector<polygon> vecShapes;
    int nMode = 0;

    bool OnUserCreate() override
    {
        polygon pent;
        float fTheta = 3.141592f * 2.0f / 5.0f;
        pent.pos = {100, 100};
        pent.angle = 0.0f;
        for (int i = 0; i < 5; i++)
        {
            pent.o.push_back({30.0f * cosf(fTheta * i), 30.0f * sinf(fTheta * i)});
            pent.p.push_back({30.0f * cosf(fTheta * i), 30.0f * sinf(fTheta * i)});
        }

        polygon tri;
        fTheta = 3.141592f * 2.0f / 3.0f;
        tri.pos = {200, 150};
        tri.angle = 0.0f;
        for (int i = 0; i < 3; i++)
        {
            tri.o.push_back({20.0f * cosf(fTheta * i), 20.0f * sinf(fTheta * i)});
            tri.p.push_back({20.0f * cosf(fTheta * i), 20.0f * sinf(fTheta * i)});
        }

        polygon rect;
        rect.pos = {50, 200};
        rect.angle = 0.0f;
        rect.o.push_back({-30, -30});
        rect.o.push_back({-30, 30});
        rect.o.push_back({30, 30});
        rect.o.push_back({30, -30});
        rect.p.resize(4);

        vecShapes.push_back(pent);
        vecShapes.push_back(tri);
        vecShapes.push_back(rect);

        return true;
    }

    bool ShapeOverlap_SAT(polygon &v1, polygon &v2)
    {
        polygon *poly1 = &v1;
        polygon *poly2 = &v2;

        for(int shape = 0; shape < 2; shape++)
        {
            if(shape == 1){
                poly1 = &v2;
                poly2 = &v1;
            }

            for(size_t a = 0; a < poly1->p.size(); a++)
            {
                int b = (a + 1) % poly1->p.size();
                vec2d axisProj = {-(poly1->p[b].y - poly1->p[a].y), poly1->p[b].x - poly1->p[a].x};
                float d = sqrtf(axisProj.x * axisProj.x + axisProj.y * axisProj.y);
                axisProj = {axisProj.x / d, axisProj.y / d};

                float min_v1 = INFINITY, max_v1 = -INFINITY;
                for (size_t p = 0; p < poly1->p.size(); p++)
                {
                    float q = (poly1->p[p].x * axisProj.x + poly1->p[p].y * axisProj.y);
                    min_v1 = std::min(min_v1, q);
                    max_v1 = std::max(max_v1, q);
                }

                float min_v2 = INFINITY, max_v2 = -INFINITY;
                for (size_t p = 0; p < poly2->p.size(); p++)
                {
                    float q = (poly2->p[p].x * axisProj.x + poly2->p[p].y * axisProj.y);
                    min_v2 = std::min(min_v2, q);
                    max_v2 = std::max(max_v2, q);
                }
                if (!(max_v2 >= min_v1 && max_v1 >= min_v2))
                    return false;
            }
        }
        return true;
    }

    bool OnUserUpdate(float fElapsedTime) override
    {
        if (GetKey(olc::Key::F1).bReleased)
            nMode = 0;
        if (GetKey(olc::Key::F2).bReleased)
            nMode = 1;
        if (GetKey(olc::Key::F3).bReleased)
            nMode = 2;
        if (GetKey(olc::Key::F4).bReleased)
            nMode = 3;

        if (GetKey(olc::Key::LEFT).bHeld)
            vecShapes[0].angle -= 2.0f * fElapsedTime;
        if (GetKey(olc::Key::RIGHT).bHeld)
            vecShapes[0].angle += 2.0f * fElapsedTime;

        if (GetKey(olc::Key::UP).bHeld)
        {
            vecShapes[0].pos.x += cosf(vecShapes[0].angle) * 60.0f * fElapsedTime;
            vecShapes[0].pos.y += sinf(vecShapes[0].angle) * 60.0f * fElapsedTime;
        }

        if (GetKey(olc::Key::DOWN).bHeld)
        {
            vecShapes[0].pos.x -= cosf(vecShapes[0].angle) * 60.0f * fElapsedTime;
            vecShapes[0].pos.y -= sinf(vecShapes[0].angle) * 60.0f * fElapsedTime;
        }

        if (GetKey(olc::Key::A).bHeld)
            vecShapes[1].angle -= 2.0f * fElapsedTime;
        if (GetKey(olc::Key::D).bHeld)
            vecShapes[1].angle += 2.0f * fElapsedTime;

        if (GetKey(olc::Key::W).bHeld)
        {
            vecShapes[1].pos.x += cosf(vecShapes[1].angle) * 60.0f * fElapsedTime;
            vecShapes[1].pos.y += sinf(vecShapes[1].angle) * 60.0f * fElapsedTime;
        }

        if (GetKey(olc::Key::S).bHeld)
        {
            vecShapes[1].pos.x -= cosf(vecShapes[1].angle) * 60.0f * fElapsedTime;
            vecShapes[1].pos.y -= sinf(vecShapes[1].angle) * 60.0f * fElapsedTime;
        }

        for (auto &v : vecShapes)
        {
            for (int i = 0; i < v.o.size(); i++)
            {
                v.p[i] = {
                    (v.o[i].x * cosf(v.angle)) - (v.o[i].y * sinf(v.angle)) + v.pos.x,
                    (v.o[i].x * sinf(v.angle)) + (v.o[i].y * cosf(v.angle)) + v.pos.y};
                v.overlap = false;
            }
        }

        for (size_t m = 0; m < vecShapes.size(); m++)
            for (int n = m + 1; n < vecShapes.size(); n++)
            {
                switch (nMode)
                {
                case 0:
                    vecShapes[m].overlap |= ShapeOverlap_SAT(vecShapes[m], vecShapes[n]);
                    break;
                case 1:
                    // vecShapes[m].overlap |= ShapeOverlap_SAT_STATIC(vecShapes[m], vecShapes[n]);
                    break;
                case 2:
                    // vecShapes[m].overlap |= ShapeOverlap_DIAGS(vecShapes[m], vecShapes[n]);
                    break;
                case 3:
                    // vecShapes[m].overlap |= ShapeOverlap_DIAGS_STATIC(vecShapes[m], vecShapes[n]);
                    break;
                }
            }

        Clear(olc::BLUE);

        for (auto &v : vecShapes)
        {
            for (int i = 0; i < v.p.size(); i++)
            {
                DrawLine(v.p[i].x, v.p[i].y, v.p[(i + 1) % v.p.size()].x, v.p[(i + 1) % v.p.size()].y, v.overlap ? olc::RED : olc::WHITE);
            }

            DrawLine(v.p[0].x, v.p[0].y, v.pos.x, v.pos.y, v.overlap ? olc::RED : olc::WHITE);
        }

        return true;
    }
};

int main()
{

    Polygon demo;
    if (demo.Construct(256, 240, 4, 4))
    {
        demo.Start();
    }

    return 0;
}
